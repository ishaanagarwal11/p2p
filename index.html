<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>suschat</title>
  <script src="https://cdn.socket.io/4.8.1/socket.io.min.js"></script>
  <style>
    body {
      font-family: "Courier New", monospace;
      margin: 0;
      padding: 0;
      background: #f5f1e6; /* cream */
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
    }
    .app {
      background: #fdfcf7; /* light beige */
      width: 90%;
      max-width: 420px;
      height: 90vh;
      display: flex;
      flex-direction: column;
    }
    header {
      background: #e6ddc6;
      color: #333;
      padding: 12px;
      text-align: center;
      font-size: 1.2em;
      font-weight: bold;
    }
    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      padding: 10px;
      background: #f2ecdb;
    }
    .controls input, .controls button {
      flex: 1;
      padding: 8px;
      font-size: 14px;
      background: #fffaf0;
      color: #333;
    }
    .controls button {
      cursor: pointer;
    }
    .controls button#createBtn,
    .controls button#joinBtn {
      background: #e8dbc5;
    }
    .controls button#disconnectBtn {
      background: #e0bfbf;
    }
    main {
      flex: 1;
      display: flex;
      flex-direction: column;
      padding: 10px;
      overflow-y: auto;
    }
    textarea {
      flex: 1;
      padding: 10px;
      font-size: 15px;
      margin-bottom: 10px;
      background: #fffaf0;
      color: #333;
    }
    .file-upload {
      margin-bottom: 10px;
      text-align: center;
    }
    .file-upload input {
      display: none;
    }
    .file-upload label {
      display: inline-block;
      padding: 8px 16px;
      background: #e8dbc5;
      cursor: pointer;
      font-size: 14px;
      color: #333;
    }
    #preview {
      margin-top: 6px;
      max-width: 100%;
      display: none;
    }
    .logs {
      display: flex;
      flex-direction: column;
      gap: 6px;
      margin-top: 10px;
    }
    #latestLogs {
      background: #f2ecdb;
      padding: 6px;
      font-size: 13px;
      max-height: 100px;
      overflow-y: auto;
    }
    #mainLogs {
      background: #fffaf0;
      padding: 6px;
      font-size: 13px;
      flex: 1;
      overflow-y: auto;
    }
  </style>
</head>
<body>
  <div class="app">
    <header>suschat</header>
    
    <div class="controls">
      <button id="createBtn">Create</button>
      <input id="pinInput" placeholder="PIN">
      <button id="joinBtn">Join</button>
      <button id="disconnectBtn">X</button>
    </div>

    <main>
      <textarea id="editor" placeholder="Start typing..."></textarea>

      <div class="file-upload">
        <label for="fileInput">sus btn</label>
        <input type="file" id="fileInput" accept="image/*">
      </div>
      <img id="preview">

      <div class="logs">
        <div id="latestLogs"></div>
        <div id="mainLogs"></div>
      </div>
    </main>
  </div>

  <script>
    const latestBox = document.getElementById("latestLogs");
    const mainBox = document.getElementById("mainLogs");

    let latestLogs = [];

    const addLog = (msg) => {
      const timestamp = Date.now();
      const entry = { msg, timestamp };

      // Add to latest logs
      latestLogs.unshift(entry);
      if (latestLogs.length > 5) {
        const moved = latestLogs.pop();
        appendToMain(moved);
      }
      renderLatest();

      // Auto-expire main logs after 1 min
      setTimeout(() => {
        const nodes = [...mainBox.childNodes];
        for (let n of nodes) {
          if (n.dataset.ts == timestamp) {
            mainBox.removeChild(n);
          }
        }
      }, 60000);
    };

    const renderLatest = () => {
    latestBox.innerHTML = "";
    latestLogs.forEach((entry) => {
        const line = document.createElement("div");
        line.textContent = entry.msg;
        line.dataset.ts = entry.timestamp;
        // Prepend newest at top
        latestBox.prepend(line);
    });
    };


    const appendToMain = (entry) => {
      const line = document.createElement("div");
      line.textContent = entry.msg;
      line.dataset.ts = entry.timestamp;
      mainBox.insertBefore(line, mainBox.firstChild);
    };

    const socket = io("https://p2p-ein8.onrender.com");

    let pc, channel, peerId;
    const editor = document.getElementById("editor");
    const fileInput = document.getElementById("fileInput");
    const preview = document.getElementById("preview");

    function createPeerConnection() {
      pc = new RTCPeerConnection({ iceServers: [{ urls: "stun:stun.l.google.com:19302" }] });

      pc.onicecandidate = (e) => {
        if (e.candidate && peerId) {
          socket.emit("signal", { to: peerId, data: { candidate: e.candidate } });
        }
      };

      pc.ondatachannel = (e) => setupChannel(e.channel);
    }

    function setupChannel(ch) {
      channel = ch;
      channel.onopen = () => addLog("Connected :)");
      channel.onclose = () => handleDisconnect();
      channel.onmessage = (e) => {
        try {
          const data = JSON.parse(e.data);
          if (data.type === "text") {
            editor.value = data.value;
          } else if (data.type === "image") {
            showImageTemporary(data.value);
            addLog("Image received :)");
          }
        } catch {
          addLog("Unknown message :(");
        }
      };
    }

    function sendData(type, value) {
      if (channel?.readyState === "open") {
        channel.send(JSON.stringify({ type, value }));
      }
    }

    editor.oninput = () => sendData("text", editor.value);

    // Resize + compress image before sending
    fileInput.onchange = () => {
      const file = fileInput.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = (e) => {
        const img = new Image();
        img.src = e.target.result;
        img.onload = () => {
        const canvas = document.createElement("canvas");
        const scale = Math.min(400 / img.width, 1);
        canvas.width = img.width * scale;
        canvas.height = img.height * scale;
        const ctx = canvas.getContext("2d");
        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
        const resized = canvas.toDataURL("image/jpeg", 0.7);

        // Show immediately
        preview.src = resized;
        preview.style.display = "block";
        addLog("Image sent :)");

        sendData("image", resized);

        // Vanish for sender too
        setTimeout(() => {
        preview.style.display = "none";
        addLog("Image vanished :)");
        }, 1000);

        // Send to peer
        sendData("image", resized);

        };
      };
      reader.readAsDataURL(file);
    };

    function showImageTemporary(src) {
      preview.src = src;
      preview.style.display = "block";
      setTimeout(() => {
        preview.style.display = "none";
        addLog("Image vanished :)");
      }, 1000);
    }

    function handleDisconnect() {
      addLog("Disconnected :(");
      editor.value = "";
      preview.style.display = "none";
      peerId = null;
      if (channel) channel.close();
      if (pc) pc.close();
      channel = null;
      pc = null;
    }

    // Socket events
    socket.on("sessionCreated", (pin) => addLog("Share PIN: " + pin));
    socket.on("peerFound", (id) => { peerId = id; });
    socket.on("peerJoined", async (id) => {
      peerId = id;
      createPeerConnection();
      const ch = pc.createDataChannel("editor");
      setupChannel(ch);

      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);
      socket.emit("signal", { to: id, data: { sdp: pc.localDescription } });
      addLog("Offer sent :)");
    });

    socket.on("signal", async ({ from, data }) => {
      peerId = from;
      if (data.sdp) {
        await pc.setRemoteDescription(new RTCSessionDescription(data.sdp));
        addLog("Got " + data.sdp.type + " :)");

        if (data.sdp.type === "offer") {
          const answer = await pc.createAnswer();
          await pc.setLocalDescription(answer);
          socket.emit("signal", { to: from, data: { sdp: pc.localDescription } });
          addLog("Answer sent :)");
        }
      } else if (data.candidate) {
        try { 
          await pc.addIceCandidate(new RTCIceCandidate(data.candidate)); 
          addLog("ICE added :)"); 
        } catch {}
      }
    });

    // Buttons
    document.getElementById("createBtn").onclick = () => {
    // 2-digit PIN (10â€“99)
    const pin = Math.floor(10 + Math.random() * 90).toString();

    // Put it in the input box
    document.getElementById("pinInput").value = pin;

    // Send to server
    socket.emit("createSession", pin);

    // Show in logs
    addLog("Session created with PIN " + pin + " :)");
    };


    document.getElementById("joinBtn").onclick = () => {
      const pin = document.getElementById("pinInput").value;
      socket.emit("joinSession", pin);
      createPeerConnection();
      addLog("Joining session " + pin + " :)");
    };

    document.getElementById("disconnectBtn").onclick = () => {
      handleDisconnect();
      addLog("You disconnected :)");
    };
  </script>
</body>
</html>
